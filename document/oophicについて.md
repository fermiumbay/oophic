# 階層的クラスを用いたオブジェクト指向プログラミング
オブジェクト指向プログラミングは、オブジェクトとよばれるものの間でやりとりされるメッセージングによりプログラムを表現する、プログラミングにおける一つのパラダイムである。
オブジェクト指向の概念がプログラミング言語のレベルでサポートされているものは数多く、一般的な実例としてはクラスと呼ばれる構造から生成されるインスタンスをオブジェクトと見なすことで実現される。
クラスはプログラムを構成する小単位の要素であるため、クラスを主体として設計することは、大規模なプログラム開発において特に有用である。
クラスを用いたプログラミングはプログラムの複雑化を抑制し、かつ抽象的でありながら多様な振る舞いを持たせることが可能であるため、幅広い分野で用いられている。

ところがクラスベースのプログラミングにおいては、ごく単純な機能であっても、メッセージングを実現するための様々な処理（アクセッサ等）を実装しなければならず、プログラムの全体的な大きさは増加しがちである。
また、既存のプログラムを流用して開発する場合においては、流用元の機能が拡張を予見できておらず、流用した処理からコピーする形で再実装しなければならなくなる場合も往々にしてある。
これらの問題は、あくまでメッセージングはクラス単体とクラス単体との間で行われるものであり、プログラミングで記述できるのはそれらの繋がりに関する情報（例えば継承や集約といった関係）しかないことから発生しうると考えられる。
記述できる情報が限られているので、これを補填する形で処理の記述量が膨大になったり、既存機能の流用時に過剰な処理の記述が残ったりすることに繋がっていることが考えられる。

そこで本書ではクラスの関係に対する記述をより多様にすべく、既存のクラスの概念を拡張した**階層的クラス**を新たに導入し、階層的クラスの図的表現によるプログラミング方法を提案する。
階層的クラスは、クラス間の関係が一通り記述された全体の関係をものに見立て、それらをすべて包み込む一つの大きなクラスを作成することを可能にしたものであり、この構造を持ったものを改めてクラスとして扱うことを許したものである。
この階層構造を持ったクラス同士は関係を持っており、その関係を記述することによって、記述の効率性を図り、全体的な処理の記述量を抑制することを図る。
本書では階層的クラス間の関係として、**階層的継承**、および**階層的集約**関係を導入する。
## 階層的クラス
階層的クラスは、複数のクラスとそれぞれの関係をまとめて要素として保持することのできるクラスである。保持されるクラスもまた階層的クラスと見なすことができ、クラスの構造を入れ子で表現することが可能である。

以下の図は、クラスClassAを継承したクラスClassBが存在し、各クラスが関数func1, func2を保持している構造を表している。クラスClassCは、これらのクラスおよび関係をすべて包含したものである。
このとき、ClassA, ClassB, ClassCはすべて階層的クラスである。
また、本書で提案する手法においては、クラスが保持する属性や関数もすべて階層的クラスの一種であると見なし、階層的クラスの関係と入れ子の関係だけでプログラム全体の構造を記述できるものとする。
すなわち、func1, func2は関数であるが、例えば処理をただ一つ持つような（関数オブジェクトのような）階層的クラスであると見なす。
属性（値のみを持つもの）については、例えばその値を返すだけの処理を持った関数を意味する階層的クラスとして表現することが考えられる。

![image](https://github.com/fermiumbay/oophic/assets/4449159/21b6e24b-acff-4829-b3bf-44b0c4d9fa0e)
## 階層的継承
階層的クラス間の継承関係を、階層的継承と呼ぶ。階層関係が同位である既存のクラス間における階層的継承関係は、既存の継承関係に類似する。

以下は、ClassAを継承したClassBを表す。ClassBのインスタンスにおいては、ClassAのfunc1はClassBのfunc1によって上書き（オーバーライド）される。
ClassAのfunc2はClassBでは記述されないので、オーバーライドされることなく、ClassBのインスタンスはClassAのfunc2をそのままの形で利用可能である。
ClassBのfunc3はClassAには存在せず、ClassBにて新規実装された関数となる。

![image](https://github.com/fermiumbay/oophic/assets/4449159/06e1aba0-bfe9-4589-b6be-a30c7981c2f1)

階層構造を持つクラスを継承した場合は、そのクラスが保持するクラスすべてを継承したものとなる。以下の図は、ClassFがClassD, ClassEを保持しており、ClassFをClassCが継承した場合の例である。
図中の「≡」は、左右の図が等価であることを意味する。
ClassFに含まれるClassD, ClassEが、ClassCに含まれるClassA, ClassBそれぞれに継承される。
この表現においては、多重継承を許した形で記述されるので、プログラミング言語に多重継承を許さない規格を設けるのであれば、何らかの制約を付加して多重にならないようにしなければならない。

![image](https://github.com/fermiumbay/oophic/assets/4449159/a30fdb63-cff5-4c78-9c1c-ef5034697ab6)

この関係が記述できることによって、既存機能におけるClassFを流用して開発する場合に、新規開発する機能一式をまとめてClassCとしてClassFを継承すればよく、ClassFからの変更点のみを記述する形で実装することが可能になる。
原理的に流用元をコピーして作成する必要がなくなり、変更点が明確になるので、多重管理による修正の展開漏れがなくなる利点がある。
## 階層的集約
階層的クラス間の集約関係を、階層的集約と呼ぶ。これは既存の集約関係と同様、クラス図としての集約関係を記述する役割を持つが、
本手法においては集約元が処理をするにあたり、自身が保持するすべてのインスタンスの処理も同時に呼び出す振る舞いをすることも表すものとする。

以下は、ClassAがClassBを集約する関係を表す。ここで、別のインスタンスがClassAのfunc1を実行した場合、ClassAがClassBのインスタンスを保持しているならば、保持しているClassBのすべてのインスタンスのfunc1も実行される。
func1はクラスであるため、実行とはfunc1をインスタンス化して処理を実行することを意味する。
このように、集約元は集約先の同名の関数をすべて実行するような振る舞いをすることが、本手法における集約の特徴である。
この振る舞いは、階層構造を持つクラスにおいても同様である。

![image](https://github.com/fermiumbay/oophic/assets/4449159/98c5ced2-c58b-41c0-bb8d-233799f79443)

クラスの設計を行うとき、なるべく多くのクラスに集約関係を持たせるよう設計すると、ほとんどのオブジェクトが何らかの別のオブジェクトを管理しているし、別のオブジェクトに管理された状態となる。
クラスの関係をそのように記述しておくとメッセージングの関係が一方向に統一されるので、双方向にメッセージングをしてしまうことによる各クラスの責務の不明瞭化を原理的に抑制することができる。
これを実現するにあたり、本記載のとおり集約関係が集約先の処理をすべて呼び出す振る舞いを行うと決めておくことで、メッセージングに関する処理を各クラスが記述する必要がなくなり、全体的な処理の記述量を減らせる利点がある。
## 階層的クラスの関係による構造の記述例
開発する製品のすべてのデータが何らかの共通的な処理を持つ場合、製品で使用されるすべてのクラスが共通処理を継承する形で記述出来れば、各クラスの実装にあたる記述量を抑制することが可能である。

以下に図の例を示す。図に現れるパッケージ、クラス、関数はすべて本書で導入した階層的クラスである。
開発する製品はすべてProductPackageの中に含まれるクラスとして作成する。個々のデータを管理するDataManager、具体的なDataA、DataB、それらの基底クラスであるBaseDataクラスがある。
それらはすべて自身の状態を更新するためのupdate関数を保持しているが、すべてのupdateの処理内容には共通する処理を挿入したい（例えば、オブジェクトが生成されてからのupdate実行回数をカウントする処理など）。
そこで、ProductPackageはCommonPackageを継承し、それに含まれるBaseObjectをすべてのクラスが継承するものとして記述する。
BaseObjectのupdateの処理本体に共通処理を記述するか、あるいはupdateはクラスであるため、そのコンストラクタ、デストラクタに共通処理を記述するかしておくことで、ProductPackage内のすべてのクラスのupdateが共通処理を実行できるようになる。
プログラムのエントリーポイントはMainClassのmain関数としておき、main関数は自身のupdate関数を継続的に呼び出す。
MainClassとBaseObjectは集約関係にあるので、MainClassのupdateを呼び出すと、BaseObjectのインスタンスのupdateも同時に呼び出される。
ProductPackageで行いたい処理がDataManagerのupdateであるとするなら、MainClassにDataManagerのインスタンスを保持させるだけでよいし、主な開発対象がProductPackageだけになる。
これにより、開発者はCommonPackageの処理について意識する必要がなくなり、本当に開発したい内容に注力した実装が可能となる（MainClassの扱いについては検討が必要）。

本手法で提案した記法により、これらのメッセージングに関する処理の実装内容について別途記述しなくとも、図だけで表現されている。
すなわち、本手法に基づくプログラミング言語では、図で既に表現されたメッセージングについては処理の実装が不要であることを意味している。

![image](https://github.com/fermiumbay/oophic/assets/4449159/5155a8b4-4745-4ef0-a48a-3e8032a872ba)
## 結び
本書では、階層的クラスとその使用に関する手法を新たに導入することを提案した。
この手法を採用することにより、メッセージングに関する処理の記述量を抑えること、既存機能の流用時における過剰な処理実装を抑えることが実現できる可能性を示した。
今後の展望として、この手法の実例となるようなプログラミング言語を開発して試運用することで、本手法の有効性について評価していくものとする。
